<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>March Madness Bracket Predictor - KenPom Edition</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    <style>
      body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }
      
      .container {
        background: white;
        border-radius: 15px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        max-width: 1400px;
      }
      
      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 30px;
        font-weight: bold;
      }
      
      .bracket-container {
        display: flex;
        justify-content: space-between;
        overflow-x: auto;
        padding: 20px 0;
        gap: 10px;
      }
      
      .round {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        min-width: 200px;
      }
      
      .round-title {
        text-align: center;
        font-weight: bold;
        color: #667eea;
        margin-bottom: 20px;
        font-size: 14px;
      }
      
      .matchup {
        background: #f8f9fa;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        padding: 10px;
        margin: 5px 0;
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s;
        position: relative;
      }
      
      .matchup:hover {
        border-color: #667eea;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }
      
      .matchup.winner {
        background: #d4edda;
        border-color: #28a745;
      }
      
      .matchup.clickable .team {
        cursor: pointer;
      }
      
      .matchup.clickable .team:hover {
        background: #e7f3ff;
      }
      
      .team {
        padding: 5px 8px;
        margin: 2px 0;
        border-radius: 4px;
        font-size: 13px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .team.selected {
        background: #28a745;
        color: white;
        font-weight: bold;
      }
      
      .team-seed {
        font-weight: bold;
        margin-right: 8px;
        min-width: 25px;
      }
      
      .team-name {
        flex: 1;
      }
      
      .team-stats {
        font-size: 10px;
        color: #6c757d;
        margin-top: 2px;
      }
      
      .controls {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 30px;
      }
      
      .team-input-form {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
      }
      
      .btn-primary {
        background: #667eea;
        border: none;
      }
      
      .btn-primary:hover {
        background: #5568d3;
      }
      
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        margin-top: 10px;
      }
      
      .stat-input {
        display: flex;
        flex-direction: column;
      }
      
      .stat-input label {
        font-size: 11px;
        color: #6c757d;
        margin-bottom: 3px;
      }
      
      .stat-input input {
        font-size: 12px;
        padding: 5px;
        border: 1px solid #ced4da;
        border-radius: 4px;
      }
      
      .team-list {
        max-height: 300px;
        overflow-y: auto;
        margin-top: 15px;
      }
      
      .team-item {
        padding: 8px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .team-item:hover {
        background: #f8f9fa;
      }
      
      .prediction-info {
        font-size: 11px;
        color: #6c757d;
        margin-top: 5px;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üèÄ March Madness Bracket Predictor</h1>
      <p class="text-center text-muted">Using KenPom Statistics to Predict Winners</p>
      
      <div class="controls">
        <h3>Add Teams</h3>
        <div class="team-input-form">
          <div class="form-group">
            <label>Team Name</label>
            <input type="text" class="form-control" id="teamName" placeholder="e.g., Michigan">
          </div>
          <div class="form-group">
            <label>Seed (1-16)</label>
            <input type="number" class="form-control" id="teamSeed" min="1" max="16" placeholder="1">
          </div>
          <div class="stats-grid">
            <div class="stat-input">
              <label>Net Rating</label>
              <input type="number" step="0.01" id="netRtg" placeholder="+35.14">
            </div>
            <div class="stat-input">
              <label>Offensive Rating</label>
              <input type="number" step="0.1" id="offRtg" placeholder="122.4">
            </div>
            <div class="stat-input">
              <label>Defensive Rating</label>
              <input type="number" step="0.1" id="defRtg" placeholder="87.3">
            </div>
            <div class="stat-input">
              <label>Adjusted Tempo</label>
              <input type="number" step="0.1" id="adjTempo" placeholder="73.0">
            </div>
            <div class="stat-input">
              <label>Luck</label>
              <input type="number" step="0.001" id="luck" placeholder="0.064">
            </div>
            <div class="stat-input">
              <label>Strength of Schedule</label>
              <input type="number" step="0.01" id="sos" placeholder="+14.03">
            </div>
          </div>
          <button class="btn btn-primary btn-block mt-3" onclick="addTeam()">Add Team</button>
        </div>
        
        <div class="mt-3">
          <button class="btn btn-success" onclick="autoFillBracket()">Auto-Fill Bracket</button>
          <button class="btn btn-warning" onclick="clearBracket()">Clear Bracket</button>
          <button class="btn btn-info" onclick="loadSampleTeams()">Load Sample Teams</button>
          <button class="btn btn-secondary" onclick="enableManualMode()">Enable Manual Selection</button>
        </div>
        
        <div class="alert alert-info mt-3" id="infoAlert" style="display: none;">
          <strong>Manual Mode:</strong> Click on teams in matchups to manually select winners. Click "Auto-Fill Bracket" again to return to auto-predictions.
        </div>
        
        <div class="team-list" id="teamList">
          <h5 class="mt-3 mb-2">Teams Added: <span id="teamCount">0</span></h5>
        </div>
      </div>
      
      <div class="bracket-container" id="bracketContainer">
        <!-- Bracket will be generated here -->
      </div>
    </div>

    <script>
      // Team data storage
      let teams = [];
      let manualMode = false;
      let bracket = {
        round1: [], // 32 matchups
        round2: [], // 16 matchups
        round3: [], // 8 matchups (Sweet 16)
        round4: [], // 4 matchups (Elite 8)
        round5: [], // 2 matchups (Final 4)
        round6: []  // 1 matchup (Championship)
      };
      
      // Enable manual selection mode
      function enableManualMode() {
        manualMode = true;
        document.getElementById('infoAlert').style.display = 'block';
        
        // Add click handlers to all matchups
        const matchups = document.querySelectorAll('.matchup');
        matchups.forEach(matchup => {
          matchup.classList.add('clickable');
          const teamDivs = matchup.querySelectorAll('.team');
          teamDivs.forEach((teamDiv, index) => {
            teamDiv.onclick = function(e) {
              e.stopPropagation();
              const roundKey = matchup.id.split('-')[0];
              const matchupIndex = parseInt(matchup.id.split('-')[1]);
              const teams = bracket[roundKey] && bracket[roundKey][matchupIndex] ? 
                [bracket[roundKey][matchupIndex].team1, bracket[roundKey][matchupIndex].team2] : 
                [null, null];
              
              if (teams[index]) {
                manuallySelectWinner(roundKey, matchupIndex, teams[index]);
              }
            };
          });
        });
      }
      
      // Manually select a winner
      function manuallySelectWinner(roundKey, matchupIndex, winner) {
        if (!bracket[roundKey] || !bracket[roundKey][matchupIndex]) return;
        
        const matchup = bracket[roundKey][matchupIndex];
        matchup.winner = winner;
        updateMatchup(roundKey, matchupIndex, matchup.team1, matchup.team2);
        
        // Propagate winner to next round
        propagateWinner(roundKey, matchupIndex, winner);
      }
      
      // Propagate winner to next round
      function propagateWinner(roundKey, matchupIndex, winner) {
        const roundOrder = ['round1', 'round2', 'round3', 'round4', 'round5', 'round6'];
        const currentIndex = roundOrder.indexOf(roundKey);
        
        if (currentIndex >= roundOrder.length - 1) return; // Championship round
        
        const nextRound = roundOrder[currentIndex + 1];
        const nextMatchupIndex = Math.floor(matchupIndex / 2);
        const positionInMatchup = matchupIndex % 2;
        
        if (!bracket[nextRound]) bracket[nextRound] = [];
        if (!bracket[nextRound][nextMatchupIndex]) {
          bracket[nextRound][nextMatchupIndex] = { team1: null, team2: null, winner: null };
        }
        
        if (positionInMatchup === 0) {
          bracket[nextRound][nextMatchupIndex].team1 = winner;
        } else {
          bracket[nextRound][nextMatchupIndex].team2 = winner;
        }
        
        // If both teams are set, predict or show the matchup
        const nextMatchup = bracket[nextRound][nextMatchupIndex];
        if (nextMatchup.team1 && nextMatchup.team2) {
          if (!manualMode) {
            nextMatchup.winner = predictWinner(nextMatchup.team1, nextMatchup.team2);
          }
          updateMatchup(nextRound, nextMatchupIndex, nextMatchup.team1, nextMatchup.team2);
        } else if (nextMatchup.team1 || nextMatchup.team2) {
          // Show partial matchup
          updateMatchup(nextRound, nextMatchupIndex, nextMatchup.team1 || { name: 'TBD', seed: 0 }, nextMatchup.team2 || { name: 'TBD', seed: 0 });
        }
      }
      
      // Initialize bracket structure
      function initBracket() {
        const rounds = [
          { name: 'Round of 64', key: 'round1', matchups: 32 },
          { name: 'Round of 32', key: 'round2', matchups: 16 },
          { name: 'Sweet 16', key: 'round3', matchups: 8 },
          { name: 'Elite 8', key: 'round4', matchups: 4 },
          { name: 'Final 4', key: 'round5', matchups: 2 },
          { name: 'Championship', key: 'round6', matchups: 1 }
        ];
        
        const container = document.getElementById('bracketContainer');
        container.innerHTML = '';
        
        rounds.forEach(round => {
          const roundDiv = document.createElement('div');
          roundDiv.className = 'round';
          
          const title = document.createElement('div');
          title.className = 'round-title';
          title.textContent = round.name;
          roundDiv.appendChild(title);
          
          for (let i = 0; i < round.matchups; i++) {
            const matchup = document.createElement('div');
            matchup.className = 'matchup';
            matchup.id = `${round.key}-${i}`;
            matchup.innerHTML = '<div class="team"><span class="team-seed">-</span><span class="team-name">TBD</span></div><div class="team"><span class="team-seed">-</span><span class="team-name">TBD</span></div>';
            roundDiv.appendChild(matchup);
          }
          
          container.appendChild(roundDiv);
        });
      }
      
      // Add team to collection
      function addTeam() {
        const team = {
          name: document.getElementById('teamName').value.trim(),
          seed: parseInt(document.getElementById('teamSeed').value),
          netRtg: parseFloat(document.getElementById('netRtg').value) || 0,
          offRtg: parseFloat(document.getElementById('offRtg').value) || 0,
          defRtg: parseFloat(document.getElementById('defRtg').value) || 0,
          adjTempo: parseFloat(document.getElementById('adjTempo').value) || 0,
          luck: parseFloat(document.getElementById('luck').value) || 0,
          sos: parseFloat(document.getElementById('sos').value) || 0
        };
        
        if (!team.name || !team.seed) {
          alert('Please enter team name and seed');
          return;
        }
        
        teams.push(team);
        updateTeamList();
        clearForm();
      }
      
      // Clear input form
      function clearForm() {
        document.getElementById('teamName').value = '';
        document.getElementById('teamSeed').value = '';
        document.getElementById('netRtg').value = '';
        document.getElementById('offRtg').value = '';
        document.getElementById('defRtg').value = '';
        document.getElementById('adjTempo').value = '';
        document.getElementById('luck').value = '';
        document.getElementById('sos').value = '';
      }
      
      // Update team list display
      function updateTeamList() {
        const list = document.getElementById('teamList');
        const count = document.getElementById('teamCount');
        count.textContent = teams.length;
        
        // Clear existing list items (keep header)
        const header = list.querySelector('h5');
        list.innerHTML = '';
        list.appendChild(header);
        list.appendChild(count.parentElement);
        
        teams.forEach((team, index) => {
          const item = document.createElement('div');
          item.className = 'team-item';
          item.innerHTML = `
            <div>
              <strong>#${team.seed} ${team.name}</strong>
              <div class="team-stats">NetRtg: ${team.netRtg.toFixed(2)} | ORtg: ${team.offRtg.toFixed(1)} | DRtg: ${team.defRtg.toFixed(1)}</div>
            </div>
            <button class="btn btn-sm btn-danger" onclick="removeTeam(${index})">Remove</button>
          `;
          list.appendChild(item);
        });
      }
      
      // Remove team
      function removeTeam(index) {
        teams.splice(index, 1);
        updateTeamList();
      }
      
      // Predict winner between two teams using KenPom stats
      function predictWinner(team1, team2) {
        if (!team1 || !team2 || team1.seed === 0 || team2.seed === 0) {
          return team1 && team1.seed !== 0 ? team1 : (team2 && team2.seed !== 0 ? team2 : null);
        }
        
        // Calculate composite score using weighted KenPom metrics
        // Net Rating is the primary indicator (45% weight) - most important stat
        // Offensive efficiency advantage (20% weight) - scoring ability
        // Defensive efficiency advantage (20% weight) - stopping opponents
        // Strength of Schedule (10% weight) - quality of competition
        // Luck adjustment (5% weight) - recent performance trends
        
        // Normalize offensive/defensive ratings (higher ORtg is better, lower DRtg is better)
        const offAdvantage1 = team1.offRtg - 100; // Baseline is 100
        const defAdvantage1 = 100 - team1.defRtg; // Lower DRtg is better
        
        const offAdvantage2 = team2.offRtg - 100;
        const defAdvantage2 = 100 - team2.defRtg;
        
        const score1 = (
          team1.netRtg * 0.45 +
          offAdvantage1 * 0.20 +
          defAdvantage1 * 0.20 +
          team1.sos * 0.10 +
          team1.luck * 50 * 0.05  // Scale luck factor
        );
        
        const score2 = (
          team2.netRtg * 0.45 +
          offAdvantage2 * 0.20 +
          defAdvantage2 * 0.20 +
          team2.sos * 0.10 +
          team2.luck * 50 * 0.05
        );
        
        // Seed-based adjustment (higher seeds get small bonus, but stats matter more)
        // This allows for upsets when lower seeds have better stats
        const seedBonus1 = (17 - team1.seed) * 0.3; // Max 4.8 points for #1 seed
        const seedBonus2 = (17 - team2.seed) * 0.3;
        
        const finalScore1 = score1 + seedBonus1;
        const finalScore2 = score2 + seedBonus2;
        
        return finalScore1 > finalScore2 ? team1 : team2;
      }
      
      // Get team by seed and region (simplified - assumes standard bracket structure)
      function getTeamForMatchup(round, matchupIndex, position) {
        if (round === 'round1') {
          // Round of 64: standard bracket pairing
          // Matchup 0: 1 vs 16, Matchup 1: 8 vs 9, Matchup 2: 5 vs 12, etc.
          const seedPairs = [
            [1, 16], [8, 9], [5, 12], [4, 13],
            [6, 11], [3, 14], [7, 10], [2, 15]
          ];
          
          const regionIndex = Math.floor(matchupIndex / 8);
          const pairIndex = matchupIndex % 8;
          const seed = seedPairs[pairIndex][position];
          
          // Find team by seed (simplified - in real bracket, need region info)
          return teams.find(t => t.seed === seed) || null;
        }
        
        return null;
      }
      
      // Auto-fill bracket based on predictions
      function autoFillBracket() {
        manualMode = false;
        document.getElementById('infoAlert').style.display = 'none';
        
        if (teams.length < 32) {
          alert(`Please add at least 32 teams for a demo bracket. Currently have ${teams.length}. Use "Load Sample Teams" for a demo.`);
          return;
        }
        
        // Group teams by seed
        const teamsBySeed = {};
        teams.forEach(team => {
          if (!teamsBySeed[team.seed]) {
            teamsBySeed[team.seed] = [];
          }
          teamsBySeed[team.seed].push(team);
        });
        
        // Standard bracket structure for Round of 64 (per region)
        const seedMatchups = [
          [1, 16], [8, 9], [5, 12], [4, 13],
          [6, 11], [3, 14], [7, 10], [2, 15]
        ];
        
        // Fill Round 1 (32 matchups)
        const round1Winners = [];
        for (let i = 0; i < 32; i++) {
          const region = Math.floor(i / 8);
          const matchupInRegion = i % 8;
          const [seed1, seed2] = seedMatchups[matchupInRegion];
          
          // Get teams - try to get unique teams per region
          let team1 = teamsBySeed[seed1] ? teamsBySeed[seed1][region % (teamsBySeed[seed1].length || 1)] : null;
          let team2 = teamsBySeed[seed2] ? teamsBySeed[seed2][region % (teamsBySeed[seed2].length || 1)] : null;
          
          // Fallback: just get first available team with that seed
          if (!team1 && teamsBySeed[seed1]) team1 = teamsBySeed[seed1][0];
          if (!team2 && teamsBySeed[seed2]) team2 = teamsBySeed[seed2][0];
          
          if (team1 && team2) {
            updateMatchup('round1', i, team1, team2);
            const winner = predictWinner(team1, team2);
            round1Winners.push(winner);
            
            if (!bracket.round1) bracket.round1 = [];
            bracket.round1[i] = { team1, team2, winner };
          } else {
            // Placeholder if teams missing
            round1Winners.push(null);
          }
        }
        
        // Fill subsequent rounds
        const round2Winners = fillRound(round1Winners, 'round2', 16);
        const round3Winners = fillRound(round2Winners, 'round3', 8);
        const round4Winners = fillRound(round3Winners, 'round4', 4);
        const round5Winners = fillRound(round4Winners, 'round5', 2);
        fillRound(round5Winners, 'round6', 1);
      }
      
      // Fill a round with predictions
      function fillRound(previousWinners, roundKey, numMatchups) {
        const roundWinners = [];
        
        for (let i = 0; i < numMatchups; i++) {
          const team1 = previousWinners[i * 2];
          const team2 = previousWinners[i * 2 + 1];
          
          if (team1 && team2) {
            updateMatchup(roundKey, i, team1, team2);
            const winner = predictWinner(team1, team2);
            roundWinners.push(winner);
            
            if (!bracket[roundKey]) bracket[roundKey] = [];
            bracket[roundKey][i] = { team1, team2, winner };
          } else if (team1 || team2) {
            // If only one team, they advance
            roundWinners.push(team1 || team2);
            if (team1) {
              updateMatchup(roundKey, i, team1, { name: 'Bye', seed: 0 });
            } else {
              updateMatchup(roundKey, i, { name: 'Bye', seed: 0 }, team2);
            }
          } else {
            roundWinners.push(null);
          }
        }
        
        return roundWinners;
      }
      
      // Update matchup display
      function updateMatchup(roundKey, matchupIndex, team1, team2) {
        const matchupEl = document.getElementById(`${roundKey}-${matchupIndex}`);
        if (!matchupEl) return;
        
        // Handle bye cases
        if (team1.name === 'Bye' || team1.seed === 0) {
          matchupEl.innerHTML = `
            <div class="team selected">
              <span class="team-seed">#${team2.seed}</span>
              <span class="team-name">${team2.name}</span>
            </div>
            <div class="team-stats">NetRtg: ${team2.netRtg.toFixed(2)}</div>
            <div class="prediction-info">Advances</div>
          `;
          matchupEl.classList.add('winner');
          return;
        }
        
        if (team2.name === 'Bye' || team2.seed === 0) {
          matchupEl.innerHTML = `
            <div class="team selected">
              <span class="team-seed">#${team1.seed}</span>
              <span class="team-name">${team1.name}</span>
            </div>
            <div class="team-stats">NetRtg: ${team1.netRtg.toFixed(2)}</div>
            <div class="prediction-info">Advances</div>
          `;
          matchupEl.classList.add('winner');
          return;
        }
        
        const winner = predictWinner(team1, team2);
        const winProb1 = calculateWinProbability(team1, team2);
        const winProb2 = 100 - winProb1;
        
        matchupEl.innerHTML = `
          <div class="team ${winner === team1 ? 'selected' : ''}">
            <span class="team-seed">#${team1.seed}</span>
            <span class="team-name">${team1.name}</span>
          </div>
          <div class="team-stats">NetRtg: ${team1.netRtg.toFixed(2)} | ${winProb1.toFixed(1)}%</div>
          <div class="team ${winner === team2 ? 'selected' : ''}">
            <span class="team-seed">#${team2.seed}</span>
            <span class="team-name">${team2.name}</span>
          </div>
          <div class="team-stats">NetRtg: ${team2.netRtg.toFixed(2)} | ${winProb2.toFixed(1)}%</div>
          <div class="prediction-info">Predicted: ${winner.name}</div>
        `;
        
        if (winner === team1 || winner === team2) {
          matchupEl.classList.add('winner');
        }
      }
      
      // Calculate win probability percentage
      function calculateWinProbability(team1, team2) {
        if (!team1 || !team2) return 50;
        
        const offAdvantage1 = team1.offRtg - 100;
        const defAdvantage1 = 100 - team1.defRtg;
        const score1 = (
          team1.netRtg * 0.45 +
          offAdvantage1 * 0.20 +
          defAdvantage1 * 0.20 +
          team1.sos * 0.10 +
          team1.luck * 50 * 0.05
        ) + (17 - team1.seed) * 0.3;
        
        const offAdvantage2 = team2.offRtg - 100;
        const defAdvantage2 = 100 - team2.defRtg;
        const score2 = (
          team2.netRtg * 0.45 +
          offAdvantage2 * 0.20 +
          defAdvantage2 * 0.20 +
          team2.sos * 0.10 +
          team2.luck * 50 * 0.05
        ) + (17 - team2.seed) * 0.3;
        
        // Convert score difference to probability using sigmoid-like function
        const diff = score1 - score2;
        const probability = 50 + (50 / (1 + Math.exp(-diff / 5)));
        
        return Math.max(5, Math.min(95, probability)); // Clamp between 5% and 95%
      }
      
      // Clear bracket
      function clearBracket() {
        initBracket();
        bracket = {
          round1: [],
          round2: [],
          round3: [],
          round4: [],
          round5: [],
          round6: []
        };
      }
      
      // Load sample teams (top teams from KenPom)
      function loadSampleTeams() {
        teams = []; // Clear existing teams
        
        // Top teams from KenPom rankings with realistic bracket distribution
        const baseTeams = [
          { name: 'Michigan', seed: 1, netRtg: 35.14, offRtg: 122.4, defRtg: 87.3, adjTempo: 73.0, luck: 0.064, sos: 14.03 },
          { name: 'Purdue', seed: 1, netRtg: 32.42, offRtg: 129.4, defRtg: 97.0, adjTempo: 66.5, luck: 0.070, sos: 5.25 },
          { name: 'Duke', seed: 1, netRtg: 32.05, offRtg: 124.6, defRtg: 92.6, adjTempo: 68.8, luck: 0.043, sos: -3.15 },
          { name: 'Iowa St.', seed: 1, netRtg: 29.65, offRtg: 122.1, defRtg: 92.5, adjTempo: 69.9, luck: 0.039, sos: 1.02 },
          { name: 'Gonzaga', seed: 2, netRtg: 29.12, offRtg: 122.3, defRtg: 93.1, adjTempo: 72.2, luck: 0.103, sos: 9.42 },
          { name: 'Connecticut', seed: 2, netRtg: 27.97, offRtg: 122.3, defRtg: 94.3, adjTempo: 66.6, luck: 0.011, sos: 1.49 },
          { name: 'Houston', seed: 2, netRtg: 27.97, offRtg: 119.2, defRtg: 91.2, adjTempo: 64.5, luck: 0.048, sos: 4.17 },
          { name: 'Louisville', seed: 2, netRtg: 27.89, offRtg: 126.0, defRtg: 98.1, adjTempo: 71.6, luck: 0.052, sos: -8.16 },
          { name: 'Arizona', seed: 3, netRtg: 27.88, offRtg: 122.5, defRtg: 94.6, adjTempo: 72.1, luck: 0.086, sos: 2.42 },
          { name: 'Vanderbilt', seed: 3, netRtg: 27.50, offRtg: 125.2, defRtg: 97.7, adjTempo: 72.3, luck: 0.030, sos: -0.27 },
          { name: 'Kentucky', seed: 3, netRtg: 26.96, offRtg: 121.9, defRtg: 94.9, adjTempo: 71.6, luck: -0.117, sos: -6.85 },
          { name: 'BYU', seed: 3, netRtg: 26.50, offRtg: 120.5, defRtg: 94.0, adjTempo: 72.8, luck: 0.099, sos: -0.43 },
          { name: 'Kansas', seed: 4, netRtg: 25.00, offRtg: 118.0, defRtg: 93.0, adjTempo: 70.0, luck: 0.050, sos: 2.00 },
          { name: 'North Carolina', seed: 4, netRtg: 24.50, offRtg: 117.5, defRtg: 93.0, adjTempo: 71.0, luck: 0.040, sos: 1.50 },
          { name: 'Villanova', seed: 5, netRtg: 23.00, offRtg: 116.0, defRtg: 93.0, adjTempo: 69.0, luck: 0.030, sos: 0.50 },
          { name: 'Baylor', seed: 5, netRtg: 22.50, offRtg: 115.5, defRtg: 93.0, adjTempo: 70.5, luck: 0.025, sos: -1.00 }
        ];
        
        // Generate teams for a full bracket (simplified - creates teams with varied stats)
        const regions = ['East', 'West', 'South', 'Midwest'];
        const seedMatchups = [
          [1, 16], [8, 9], [5, 12], [4, 13],
          [6, 11], [3, 14], [7, 10], [2, 15]
        ];
        
        for (let region = 0; region < 4; region++) {
          for (let matchup = 0; matchup < 8; matchup++) {
            const [seed1, seed2] = seedMatchups[matchup];
            
            // Get base team stats and adjust for seed
            const base1 = baseTeams[(seed1 - 1) % baseTeams.length];
            const base2 = baseTeams[(seed2 - 1) % baseTeams.length];
            
            teams.push({
              name: `${base1.name} (${regions[region]})`,
              seed: seed1,
              netRtg: base1.netRtg - (seed1 - 1) * 1.5,
              offRtg: base1.offRtg - (seed1 - 1) * 0.8,
              defRtg: base1.defRtg + (seed1 - 1) * 0.5,
              adjTempo: base1.adjTempo,
              luck: base1.luck,
              sos: base1.sos - (seed1 - 1) * 0.5
            });
            
            teams.push({
              name: `${base2.name} (${regions[region]})`,
              seed: seed2,
              netRtg: base2.netRtg - (seed2 - 1) * 1.5,
              offRtg: base2.offRtg - (seed2 - 1) * 0.8,
              defRtg: base2.defRtg + (seed2 - 1) * 0.5,
              adjTempo: base2.adjTempo,
              luck: base2.luck,
              sos: base2.sos - (seed2 - 1) * 0.5
            });
          }
        }
        
        updateTeamList();
        alert(`Loaded ${teams.length} sample teams across 4 regions. Click "Auto-Fill Bracket" to generate predictions!`);
      }
      
      // Initialize on page load
      initBracket();
    </script>
  </body>
</html>
